/*****************************************************************************
 *                   Yumetech, Inc Copyright (c) 2004 - 2006
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.j3d.aviatrix3d;

// External imports

import javax.media.opengl.GL;

// Local imports
import org.j3d.aviatrix3d.rendering.ComponentRenderable;
import org.j3d.aviatrix3d.rendering.ShaderComponentRenderable;
import org.j3d.aviatrix3d.rendering.ShaderRenderable;

import org.j3d.util.IntHashMap;

/**
 * Shader handler for shaders written with the OpenGL GLSLang 1.0 shader language.
 * <p>
 *
 * A shader consists of the compiled program source and a set of arguments. The
 * compiled source is represented by the {@link ShaderProgram} class. Uniform
 * variable arguments are provided through the {@link ShaderArguments} class,
 * while attribute variable values are directly provided as part of the
 * {@link VertexGeometry}.
 * <p>
 *
 * This allows a single program to be used multiple times and just change the
 * argument values depending on the object to be rendered, without needing
 * two completely separate sets of shaders.
 *
 *
 * @author Justin Couch
 * @version $Revision: 1.15 $
 */
public class GLSLangShader extends Shader
    implements ShaderRenderable
{
    /**
     * Global mapping of ints to Integer instances. Used to reduce the amount
     * of garbage generated by reusing non-changing values.
     */
    private IntHashMap idMap = new IntHashMap();

    /** Set of arguments used for this shader instance */
    private ShaderArguments arguments;

    /** The compiled source version of the shader */
    private ShaderProgram program;

    /** Flag indicating that validation is required on next use */
    private boolean validationRequired;

    /** Flag describing whether the complete shader is validated */
    private boolean programIsValid;

    /**
     * Constructs a shader with nothing set. When used, it will have no effect.
     */
    public GLSLangShader()
    {
        validationRequired = false;
        programIsValid = true;
    }

    //---------------------------------------------------------------
    // Methods defined by ShaderRenderable
    //---------------------------------------------------------------

    /**
     * Get an object that represents arguments that should be passed along
     * with the shader. If the shader has a full program component renderable.
     * then it will most likely have arguments too.
     *
     * @return An object representing any global argument lists
     */
    public ComponentRenderable getArgumentsRenderable()
    {
        return arguments;
    }

    /**
     * Get the component of this shader, if it has one. If the given type
     * is not recognised by this shader, return null.
     *
     * @param type One of the _SHADER constants from
     *    {@link ShaderComponentRenderable}
     * @return A matching component or null if none
     */
    public ShaderComponentRenderable getShaderRenderable(int type)
    {
        return (type == ShaderComponentRenderable.PROGRAM_SHADER) ?
               program : null;
    }

    //---------------------------------------------------------------
    // Methods defined by ObjectRenderable
    //---------------------------------------------------------------

    /**
     * Issue ogl commands needed for this component
     *
     * @param gl The gl context to draw with
     */
    public void render(GL gl)
    {
        if(program == null || !program.isValid(gl))
            return;

        program.render(gl);

        if(arguments != null)
        {
            int id = program.getProgramId(gl);

            Integer i_id = (Integer)idMap.get(id);
            if(i_id == null)
            {
                i_id = new Integer(id);
                idMap.put(id, i_id);
            }

            arguments.render(gl, i_id);
        }

        if(validationRequired)
        {
            int id = program.getProgramId(gl);
            gl.glValidateProgramARB(id);

            int[] bool = new int[1];
            gl.glGetObjectParameterivARB(id,
                                         GL.GL_OBJECT_VALIDATE_STATUS_ARB,
                                         bool,
                                         0);
            programIsValid = (bool[0] == 1);
        }
    }

    /**
     * Restore all openGL state to the given drawable
     *
     * @param gl The gl context to draw with
     */
    public void postRender(GL gl)
    {
        if(program == null || !program.isValid(gl))
            return;

        program.postRender(gl);

        if(arguments != null)
        {
            int id = program.getProgramId(gl);
            Integer i_id = (Integer)idMap.get(id);
            arguments.postRender(gl, i_id);
        }
    }

    //---------------------------------------------------------------
    // Methods defined by SceneGraphObject
    //---------------------------------------------------------------

    /**
     * Set the scenegraph update handler for this node.  It will notify
     * all its children of the value. A null value will clear the current
     * handler.
     *
     * @param handler The instance to use as a handler
     */
    protected void setUpdateHandler(NodeUpdateHandler handler)
    {
        if(handler == updateHandler)
            return;

        super.setUpdateHandler(handler);

        if(program != null)
            program.setUpdateHandler(updateHandler);

        if(arguments != null)
            arguments.setUpdateHandler(updateHandler);
    }

    /**
     * Notification that this object is live now. Overridden to make sure that
     * the live state of the nodes represents the same state as the parent
     * scene graph.
     *
     * @param state true if this should be marked as live now
     */
    protected void setLive(boolean state)
    {
        if(state)
            liveCount++;
        else if(liveCount > 0)
            liveCount--;

        if((liveCount == 0) || !alive)
        {
            if(program != null)
                program.setLive(state);

            if(arguments != null)
                arguments.setLive(state);

            super.setLive(state);
        }
    }

    //---------------------------------------------------------------
    // Methods defined by Comparable
    //---------------------------------------------------------------

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     *
     * @param o The objec to be compared
     * @return -1, 0 or 1 depending on order
     * @throws ClassCastException The specified object's type prevents it from
     *    being compared to this Object
     */
    public int compareTo(Object o)
        throws ClassCastException
    {
        GLSLangShader sh = (GLSLangShader)o;
        return compareTo(sh);
    }

    //---------------------------------------------------------------
    // Methods defined by Object
    //---------------------------------------------------------------

    /**
     * Compare this object for equality to the given object.
     *
     * @param o The object to be compared
     * @return True if these represent the same values
     */
    public boolean equals(Object o)
    {
        if(!(o instanceof GLSLangShader))
            return false;
        else
            return equals((GLSLangShader)o);
    }

    //---------------------------------------------------------------
    // Local Methods
    //---------------------------------------------------------------

    /**
     * Set the shader program to be used on this object. Program instances may
     * be shared between multiple primitives. A value of null will remove the
     * currently set shader from being used.
     *
     * @param prog The program instance to use or null
     * @throws InvalidWriteTimingException An attempt was made to write outside
     *   of the NodeUpdateListener data changed callback method
     */
    public void setShaderProgram(ShaderProgram prog)
        throws InvalidWriteTimingException
    {
        if(isLive() && updateHandler != null &&
           !updateHandler.isDataWritePermitted(this))
            throw new InvalidWriteTimingException(getDataWriteTimingMessage());

        if(program != null)
            program.setLive(false);

        program = prog;

        if(program != null)
        {
            program.setLive(alive);
            program.setUpdateHandler(updateHandler);
        }
    }

    /**
     * Get the currently set shader program instance. If none is set, this will
     * return null.
     *
     * @return The current instance or null
     */
    public ShaderProgram getShaderProgram()
    {
        return program;
    }

    /**
     * Set the shader arguments to be used on this object. Argument instances
     * may be shared between multiple primitives. A value of null will remove
     * the currently set arguments, returning them to their default values
     * which are the last set values according to the OGL spec).
     *
     * @param arg The argument instance to use or null
     * @throws InvalidWriteTimingException An attempt was made to write outside
     *   of the NodeUpdateListener data changed callback method
     */
    public void setShaderArguments(ShaderArguments arg)
        throws InvalidWriteTimingException
    {
        if(isLive() && updateHandler != null &&
           !updateHandler.isDataWritePermitted(this))
            throw new InvalidWriteTimingException(getDataWriteTimingMessage());

        if(arguments != null)
            arguments.setLive(false);

        arguments = arg;

        if(arguments != null)
        {
            arguments.setLive(alive);
            arguments.setUpdateHandler(updateHandler);
        }
    }

    /**
     * Get the currently set shader arguments instance. If none is set, this will
     * return null.
     *
     * @return The current instance or null
     */
    public ShaderArguments getShaderArguments()
    {
        return arguments;
    }

    /**
     * Request that the shader validate it's code at the next available
     * oppourtunity. Note that this is purely a debugging capability provided
     * for shader programs and you should not be calling this in production
     * code. It will cause severe performance impacts.
     * <p>
     * Also note that the validation can only take place in the course of the
     * normal runtime processing of the render loop as it validates whether the
     * shader can execute given the current complete OpenGL state. If the
     * shader is currently on a primitive that is not visible on screen, it
     * will not be validated until it is visible.
     *
     * @throws InvalidWriteTimingException An attempt was made to write outside
     *   of the NodeUpdateListener data changed callback method
     */
    public void validate()
        throws InvalidWriteTimingException
    {
        if(isLive() && updateHandler != null &&
           !updateHandler.isDataWritePermitted(this))
            throw new InvalidWriteTimingException(getDataWriteTimingMessage());

        validationRequired = true;
    }

    /**
     * Check on the current validation state. This will always return true
     * unless the user asks for explicit validation via the validate() method.
     *
     * @return true always unless the user requests explicit validation
     */
    public boolean isValidated()
    {
        return programIsValid;
    }

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     *
     * @param sh The shader instances to be compared
     * @return -1, 0 or 1 depending on order
     */
    public int compareTo(GLSLangShader sh)
    {
        if(sh == null)
            return 1;

        if(sh == this)
            return 0;

        if(program != sh.program)
        {
            if(program == null)
                return -1;
            else if(sh.program == null)
                return 1;

            int res = program.compareTo(sh.program);
            if(res != 0)
                return res;
        }

        if(arguments != sh.arguments)
        {
            if(arguments == null)
                return -1;
            else if(sh.arguments == null)
                return 1;

            int res = arguments.compareTo(sh.arguments);
            if(res != 0)
                return res;
        }

        return 0;
    }

    /**
     * Compares this object with the specified object to check for equivalence.
     *
     * @param sh The shader instance to be compared
     * @return true if the objects represent identical values
     */
    public boolean equals(GLSLangShader sh)
    {
        if(sh == this)
            return true;

        if(sh == null)
            return false;

        if(program != sh.program)
        {
            if((program == null) || !program.equals(sh.program))
                return false;
        }

        if(arguments != sh.arguments)
        {
            if((arguments == null) || !arguments.equals(sh.arguments))
                return false;
        }

        return true;
    }
}
