/*****************************************************************************
 *                     Yumetech, Inc Copyright (c) 2004-2005
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.j3d.renderer.aviatrix3d.geom.hanim;

// External imports
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.text.MessageFormat;
import java.util.Locale;

import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2;

import org.j3d.util.DefaultErrorReporter;
import org.j3d.util.ErrorReporter;
import org.j3d.util.IntHashMap;
import org.j3d.util.I18nManager;

// Local imports
import org.j3d.aviatrix3d.NodeUpdateHandler;
import org.j3d.aviatrix3d.Shader;
import org.j3d.aviatrix3d.ShaderArguments;
import org.j3d.aviatrix3d.ShaderObject;
import org.j3d.aviatrix3d.ShaderProgram;

import org.j3d.aviatrix3d.rendering.ComponentRenderable;
import org.j3d.aviatrix3d.rendering.ShaderComponentRenderable;

/**
 * Custom Shader implementation for dealing with the needs of hardware shaded
 * HAnim characters.
 * <p>
 *
 * To render the characters within a general scene, we need to know about the
 * surrounding structures, such as lights, textures etc. This custom
 * implementation is needed so that we can query the entire pipeline state just
 * before enabling the shader, so that the information can be passed into the
 * shader directly.
 * <p>
 * <b>Internationalisation Resource Names</b>
 * <ul>
 * <li>missingShaderMsg: Error message unable to find the basic shader
 *     definition files.</li>
 * <li>shaderFileCorruptMsg: Error message reading a file and it ends up with
 *     an I/O error of some kind.</li>
 * </ul>
 *
 * @author Justin Couch
 * @version $Revision: 1.9 $
 */
class HAnimShader extends Shader
    implements Comparable
{
    /** Message when the shader source file can't be found */
    private static final String MISSING_SHADER_PROP =
        "org.j3d.renderer.aviatrix3d.geom.hanim.HAnimShader.missingShaderMsg";

    /** Message when the shader file is corrupted in some way */
    private static final String BAD_SHADER_PROP =
        "org.j3d.renderer.aviatrix3d.geom.hanim.HAnimShader.shaderFileCorruptMsg";

    /** Index of the attribute for the vertex weight */
    protected static final int WEIGHT_ATTRIB_INDEX = 6;

    /** Index of the attribute for the vertex matrix indices */
    protected static final int MATRIX_ATTRIB_INDEX = 7;

    /** The location and name of the core shader file */
    private static final String CORE_SHADER_FILE =
        "org/j3d/renderer/aviatrix3d/geom/hanim/mesh_skin.vert";

    /** The location and name of the core shader file */
    private static final String LIGHTING_SHADER_FILE =
        "standard/lighting.vert";

    /** The location and name of the core shader file */
    private static final String FOG_SHADER_FILE =
        "standard/fog.frag";

    /** The location and name of the core shader file */
    private static final String FOG_COORD_SHADER_FILE =
        "standard/fog.vert";

    /** The location and name of the core shader file */
    private static final String TEXTURE_SHADER_FILE =
        "standard/texture.frag";

    /** The shader files in load order */
    private static final String[] SHADER_FILES =
    {
        CORE_SHADER_FILE,
        LIGHTING_SHADER_FILE,
        FOG_COORD_SHADER_FILE,
        TEXTURE_SHADER_FILE,
        FOG_SHADER_FILE
    };

    /** The compiled source version of the shader */
    private static HAnimShaderProgram program;

    /**
     * Global mapping of ints to Integer instances. Used to reduce the amount
     * of garbage generated by reusing non-changing values.
     */
    private IntHashMap idMap;

    /** Set of arguments used for this shader instance */
    private ShaderArguments arguments;

    /** Flag to say if we've received our initial log from the Shader link */
    private boolean shaderLogRecieved;

    /** Local reporter to put errors in */
    private ErrorReporter errorReporter;

    /** Holder of the current light state. The shader source has room for 8 only */
    private int[] lightState;

    /** Single length flag for the enabled state of lighting in general */
    private int[] lightEnabled;

    /** Holder of the fog state and type */
    private int[] fogType;

    /** The maximum number of valid texture units to play with */
    private int[] maxTextures;

    static
    {

        InputStream[] is = AccessController.doPrivileged(
            new PrivilegedAction<InputStream[]>()
            {
                public InputStream[] run()
                {
                    InputStream[] ret_val = new InputStream[SHADER_FILES.length];

                    for(int i = 0; i < SHADER_FILES.length; i++)
                        ret_val[i] = ClassLoader.getSystemResourceAsStream(SHADER_FILES[i]);

                    return ret_val;
                }
            }
        );

        // Fallback mechanism for WebStart
        ClassLoader cldr = HAnimShader.class.getClassLoader();
        for(int i = 0; i < SHADER_FILES.length; i++)
        {
            if(is[i] == null)
                is[i] = (InputStream)cldr.getResourceAsStream(SHADER_FILES[i]);
        }

        for(int i = 0; i < SHADER_FILES.length; i++)
        {
            if(is[i] == null)
            {
                I18nManager intl_mgr = I18nManager.getManager();
                Locale lcl = intl_mgr.getFoundLocale();
                String msg_pattern = intl_mgr.getString(MISSING_SHADER_PROP);

                Object[] msg_args = { SHADER_FILES[i] };
                MessageFormat msg_fmt =
                    new MessageFormat(msg_pattern, lcl);
                String msg = msg_fmt.format(msg_args);

                throw new RuntimeException(msg);
            }
        }

        program = new HAnimShaderProgram();

        for(int i = 0; i < is.length; i++)
        {
            InputStreamReader isr = new InputStreamReader(is[i]);
            BufferedReader rdr = new BufferedReader(isr);

            StringBuffer str_buf = new StringBuffer(2048);
            char[] buf = new char[1024];
            int read;

            try
            {
                while((read = rdr.read(buf, 0, 1024)) != -1)
                    str_buf.append(buf, 0, read);
            }
            catch(IOException ioe)
            {
                I18nManager intl_mgr = I18nManager.getManager();
                Locale lcl = intl_mgr.getFoundLocale();
                String msg_pattern = intl_mgr.getString(BAD_SHADER_PROP);

                Object[] msg_args = { SHADER_FILES[i] };
                MessageFormat msg_fmt =
                    new MessageFormat(msg_pattern, lcl);
                String msg = msg_fmt.format(msg_args);

                throw new RuntimeException(msg, ioe);
            }
            finally
            {
                try
                {
                    is[i].close();
                }
                catch(IOException ioe)
                {
                    // ignored for this case
                }
            }

            String[] src = { str_buf.toString() };

            // Items in the array after thr 4th index are fragment shaders, before
            // are vertex shaders.
            ShaderObject shader = new ShaderObject(true);
            shader.setSourceStrings(src, 1);
            shader.compile();
            shader.requestInfoLog();

            program.addShaderObject(shader);
        }

        program.bindAttributeName("weight", WEIGHT_ATTRIB_INDEX);
        program.bindAttributeName("matrixIndex", MATRIX_ATTRIB_INDEX);

        program.link();
        program.requestLinkConfirmation(true);
        program.requestInfoLog();
    }

    /**
     * Constructs a shader with nothing set. When used, it will have no effect.
     */
    HAnimShader()
    {
        idMap = new IntHashMap();
        arguments = new ShaderArguments();
        shaderLogRecieved = false;
        lightState = new int[8];
        lightEnabled = new int[1];
        fogType = new int[1];
        maxTextures = new int[1];

        errorReporter = DefaultErrorReporter.getDefaultReporter();
    }

    //---------------------------------------------------------------
    // Methods defined by ShaderRenderable
    //---------------------------------------------------------------

    /**
     * Get an object that represents arguments that should be passed along
     * with the shader. If the shader has a full program component renderable.
     * then it will most likely have arguments too.
     *
     * @return An object representing any global argument lists
     */
    @Override
    public ComponentRenderable getArgumentsRenderable()
    {
        return arguments;
    }

    /**
     * Get the component of this shader, if it has one. If the given type
     * is not recognised by this shader, return null.
     *
     * @param type One of the _SHADER constants from
     *    {@link ShaderComponentRenderable}
     * @return A matching component or null if none
     */
    @Override
    public ShaderComponentRenderable getShaderRenderable(int type)
    {
        return (type == ShaderComponentRenderable.PROGRAM_SHADER) ?
               program : null;
    }

    //---------------------------------------------------------------
    // Methods defined by ObjectRenderable
    //---------------------------------------------------------------

    /**
     * Issue ogl commands needed for this component
     *
     * @param gl The gl context to draw with
     */
    @Override
    public void render(GL2 gl)
    {
        if(program == null || !program.isValid(gl))
            return;

        program.render(gl);

        int id = program.getProgramId(gl);

        Integer i_id = (Integer)idMap.get(id);
        if(i_id == null)
        {
            i_id = new Integer(id);
            idMap.put(id, i_id);
        }

        // Now go through finding out what is currently set for the state and
        // push it through to the arguments class.
        lightState[0] = gl.glIsEnabled(GL2.GL_LIGHT0) ? 1 : 0;
        lightState[1] = gl.glIsEnabled(GL2.GL_LIGHT1) ? 1 : 0;
        lightState[2] = gl.glIsEnabled(GL2.GL_LIGHT2) ? 1 : 0;
        lightState[3] = gl.glIsEnabled(GL2.GL_LIGHT3) ? 1 : 0;
        lightState[4] = gl.glIsEnabled(GL2.GL_LIGHT4) ? 1 : 0;
        lightState[5] = gl.glIsEnabled(GL2.GL_LIGHT5) ? 1 : 0;
        lightState[6] = gl.glIsEnabled(GL2.GL_LIGHT6) ? 1 : 0;
        lightState[7] = gl.glIsEnabled(GL2.GL_LIGHT7) ? 1 : 0;

        lightEnabled[0] = lightState[0] + lightState[1] + lightState[2] +
                          lightState[3] + lightState[4] + lightState[5] +
                          lightState[6] + lightState[7];

        // is lighting generally enabled?
        arguments.setUniform("lightingEnabled",
                             1,
                             lightEnabled,
                             1);

        arguments.setUniform("enabledLights", 1, lightState, 8);

        if(gl.glIsEnabled(GL2.GL_FOG))
        {
            gl.glGetIntegerv(GL2.GL_FOG_COORDINATE_SOURCE, fogType, 0);
            switch(fogType[0])
            {
                case GL2.GL_FOG_COORDINATE:
                    fogType[0] = 1;
                    break;

                case GL2.GL_FRAGMENT_DEPTH:
                    fogType[0] = 2;
                    break;
            }
        }
        else
            fogType[0] = 0;


        arguments.setUniform("fogSourceType", 1, fogType, 1);

        arguments.render(gl, i_id);

        if(!shaderLogRecieved)
        {
            String msg;

            int num_objs = program.getNumShaderObjects();
            ShaderObject[] objs = new ShaderObject[num_objs];
            program.getShaderObjects(objs);

            for(int i = 0; i < num_objs; i++)
            {
                msg = objs[i].getLastInfoLog();
                if(msg != null && msg.length() != 0)
                    errorReporter.messageReport("HAnim compile msg (" + i +
                                                "): " + msg);
            }

            msg = program.getLastInfoLog();
            if(msg != null && msg.length() != 0)
                errorReporter.messageReport("HAnim Link msg: " + msg);

            shaderLogRecieved = true;
        }
    }

    /**
     * Restore all openGL state to the given drawable
     *
     * @param gl The gl context to draw with
     */
    @Override
    public void postRender(GL2 gl)
    {
        if(program == null || !program.isValid(gl))
            return;

        program.postRender(gl);

        // No need to call postRender on ShaderArguments as nothing happens.
    }

    //---------------------------------------------------------------
    // Methods defined by SceneGraphObject
    //---------------------------------------------------------------

    /**
     * Set the scenegraph update handler for this node.  It will notify
     * all its children of the value. A null value will clear the current
     * handler.
     *
     * @param handler The instance to use as a handler
     */
    @Override
    protected void setUpdateHandler(NodeUpdateHandler handler)
    {
        super.setUpdateHandler(handler);

        if(program != null)
            program.setUpdateHandler(updateHandler);
    }

    /**
     * Notification that this object is live now. Overridden to make sure that
     * the live state of the nodes represents the same state as the parent
     * scene graph.
     *
     * @param state true if this should be marked as live now
     */
    @Override
    protected void setLive(boolean state)
    {
        if(state)
            liveCount++;
        else if(liveCount > 0)
            liveCount--;

        if((liveCount == 0) || !alive)
        {
            if(program != null)
                program.setLive(state);

            super.setLive(state);
        }
    }

    //---------------------------------------------------------------
    // Methods defined by Comparable
    //---------------------------------------------------------------

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     *
     * @param o The objec to be compared
     * @return -1, 0 or 1 depending on order
     * @throws ClassCastException The specified object's type prevents it from
     *    being compared to this Object
     */
    @Override
    public int compareTo(Object o)
        throws ClassCastException
    {
        HAnimShader sh = (HAnimShader)o;
        return compareTo(sh);
    }

    //---------------------------------------------------------------
    // Methods defined by Object
    //---------------------------------------------------------------

    /**
     * Compare this object for equality to the given object.
     *
     * @param o The object to be compared
     * @return True if these represent the same values
     */
    @Override
    public boolean equals(Object o)
    {
        if(!(o instanceof HAnimShader))
            return false;
        else
            return equals((HAnimShader)o);
    }

    //---------------------------------------------------------------
    // Local Methods
    //---------------------------------------------------------------

    /**
     * Set the shader arguments to be used on this object. Argument instances
     * may be shared between multiple primitives. A value of null will remove
     * the currently set arguments, returning them to their default values
     * which are the last set values according to the OGL spec).
     */
    ShaderArguments getShaderArguments()
    {
        return arguments;
    }

    /**
     * Set the maximum number of texture units to play with as a hint to pass
     * to the shader.
     */
    void setMaxTextureUnits(int num)
    {
        maxTextures[0] = num;
        arguments.setUniform("numTextures", 1, maxTextures, 1);
    }

    /**
     * Register an error reporter with the object so that any errors generated
     * by the object can be reported in a nice, pretty fashion.
     * Setting a value of null will clear the currently set reporter. If one
     * is already set, the new value replaces the old.
     *
     * @param reporter The instance to use or null
     */
    void setErrorReporter(ErrorReporter reporter)
    {
        errorReporter = reporter;

        if(reporter == null)
            errorReporter = DefaultErrorReporter.getDefaultReporter();
    }

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     *
     * @param sh The shader instances to be compared
     * @return -1, 0 or 1 depending on order
     */
    int compareTo(HAnimShader sh)
    {
        if(sh == null)
            return 1;

        if(sh == this)
            return 0;

        if(arguments != sh.arguments)
        {
            int res = arguments.compareTo(sh.arguments);
            if(res != 0)
                return res;
        }

        return 0;
    }

    /**
     * Compares this object with the specified object to check for equivalence.
     *
     * @param sh The shader instance to be compared
     * @return true if the objects represent identical values
     */
    boolean equals(HAnimShader sh)
    {
        if(sh == this)
            return true;

        if(sh == null)
            return false;

        if((arguments == null) || !arguments.equals(sh.arguments))
            return false;

        return true;
    }
}
